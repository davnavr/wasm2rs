---
source: crates/convert/tests/main.rs
expression: "String::from_utf8_lossy(&rust)"
---
// Generated by wasm2rs 0.1.0
macro_rules! wasm {
    ($vis:vis mod $module:ident use $(:: $embedder_start:ident ::)? $($embedder_more:ident)::+) => {

#[allow(non_snake_case)]
#[allow(dead_code)]
#[allow(unreachable_code)]
#[allow(unreachable_pub)]
#[allow(unused_mut)]
$vis mod $module {

use $(::$embedder_start::)? $($embedder_more)::+ as embedder;
use embedder::rt::trap::TrapWith as _;

pub struct Instance {
    pub imports: embedder::Imports,
    _g0: i32,
}

impl Instance {

    pub fn instantiate(store: embedder::Store) -> ::core::result::Result<embedder::Module<Self>, embedder::Trap> {
        let allocated = Self {
            imports: store.imports,
            _g0: Default::default(),
        };
        let mut module = embedder::rt::store::AllocateModule::allocate(store.instance, allocated);
        embedder::rt::memory::check_limits(module.imports.tests().memory(), 0, 1, <u32 as embedder::rt::memory::Address>::MAX_PAGE_COUNT)?;
        let mut inst: &mut Self = embedder::rt::store::ModuleAllocation::get_mut(&mut module);
        inst._g0 = inst.imports.tests().FORTY();
        Ok(module)
    }

fn _f1(&self) -> i32 {
    i32::wrapping_add(self._g0, 2i32)
}

pub fn funny_life_number(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(self._f1())
}

pub fn two_equals_two(&self) -> ::core::result::Result<(), embedder::Trap> {
    self.imports.tests().assert_equal(2i32, 2i32)?;
    Ok(())
}

pub fn write_5_to_5000(&self) -> ::core::result::Result<(), embedder::Trap> {
    embedder::rt::memory::i32_store::<0, u32, _, _>(self.imports.tests().memory(), 0, 0x1388i32, 5i32, None)?;
    Ok(())
}
    const _SYM_FN_1: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(1, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 146 }); sym.export_names = &["funny_life_number"]; sym };
    const fn _frame_fn_1(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_1, o) }
    const _SYM_FN_2: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(2, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 154 }); sym.export_names = &["two_equals_two"]; sym };
    const fn _frame_fn_2(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_2, o) }
    const _SYM_FN_3: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(3, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 163 }); sym.export_names = &["write_5_to_5000"]; sym };
    const fn _frame_fn_3(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_3, o) }

} // impl Instance

} // mod $module

    }
}
