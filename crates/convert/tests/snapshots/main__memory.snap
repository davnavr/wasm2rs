---
source: crates/convert/tests/main.rs
expression: "String::from_utf8_lossy(&rust)"
---
// Generated by wasm2rs 0.1.0
macro_rules! wasm {
    ($vis:vis mod $module:ident use $(:: $embedder_start:ident ::)? $($embedder_more:ident)::+) => {

#[allow(non_snake_case)]
#[allow(dead_code)]
#[allow(unreachable_code)]
#[allow(unreachable_pub)]
$vis mod $module {

use $(::$embedder_start::)? $($embedder_more)::+ as embedder;
use embedder::rt::trap::TrapWith as _;

pub struct Instance {
    imports: embedder::Imports,
    _m: embedder::Memory0,
}

impl Instance {

    pub fn r#mem(&self) -> &embedder::Memory0 {
        &self._m
    }


    pub fn instantiate(store: embedder::Store) -> ::core::result::Result<embedder::Module<Self>, embedder::Trap> {
        let allocated = Self {
            imports: store.imports,
            _m: embedder::rt::store::AllocateMemory::allocate(store.memory0, 0, 1, 4294967295)?,
        };
        let mut module = embedder::rt::store::AllocateModule::allocate(store.instance, allocated);
        Ok(module)
    }

pub fn r#write_my_int(&self) -> ::core::result::Result<(), embedder::Trap> {
    embedder::rt::memory::i32_store::<0, u32, _, _>(&self._m, 0, 0x1F4i32, 0x41i32, None)?;
    Ok(())
}

pub fn r#read_my_int(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(embedder::rt::memory::i32_load::<0, u32, _, _>(&self._m, 0, 0x1F4i32, None)?)
}

pub fn r#out_of_bounds_read(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(embedder::rt::memory::i32_load::<0, u32, _, _>(&self._m, 0, 0x00010000i32, None)?)
}

pub fn r#grow_then_write(&self) -> ::core::result::Result<i32, embedder::Trap> {
    let mut _l0 = 0i32;
    let mut _l1 = 0i32;
    _l0 = embedder::rt::memory::size(&self._m);
    _l1 = i32::wrapping_add(i32::wrapping_mul(_l0, 0x00010000i32), 0x10i32);
    embedder::rt::memory::grow(&self._m, i32::wrapping_add(1i32, _l0));
    embedder::rt::memory::i32_store::<0, u32, _, _>(&self._m, 0, _l1, 0xBABAi32, None)?;
    Ok(embedder::rt::memory::i32_load::<0, u32, _, _>(&self._m, 0, _l1, None)?)
}

} // impl Instance

} // mod $module

    }
}
