---
source: crates/convert/tests/main.rs
expression: "String::from_utf8_lossy(&rust)"
---
// Generated by wasm2rs 0.1.0
macro_rules! wasm {
    ($vis:vis mod $module:ident use $(:: $embedder_start:ident ::)? $($embedder_more:ident)::+) => {

#[allow(non_snake_case)]
#[allow(dead_code)]
#[allow(unreachable_code)]
#[allow(unreachable_pub)]
#[allow(unused_mut)]
#[allow(unused_imports)]
$vis mod $module {

use $(::$embedder_start::)? $($embedder_more)::+ as embedder;
use embedder::rt::{trap::TrapWith as _, trace::UnwindWith as _};

pub struct Module {
    pub imports: embedder::Imports,
    _g1: embedder::rt::global::Global<i32>,
} // struct Module

#[repr(transparent)]
pub struct Instance(::core::option::Option<embedder::Module<Module>>);

impl Module {
    const _G0: i32 = 0x400i32;

    pub fn counter(&self) -> &embedder::rt::global::Global<i32> {
        &self._g1
    }

fn _f0(mut _l0: i32) -> i32 {
    i32::wrapping_add(_l0, 5i32)
}

pub fn add_five(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f0(_l0))
}

pub fn add_fifteen(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f0(Self::_f0(Self::_f0(_l0))))
}

fn _f2(mut _l0: i32) -> i32 {
    let (_t0, _t1) = '_b0: {
        (_l0, _l0)
    }; // '_b0
    i32::wrapping_add(_t0, _t1)
}

pub fn block_me_up(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f2(_l0))
}

fn _f3() -> ::core::result::Result<i32 /* ! */, embedder::Trap> {
    return ::core::result::Result::Err(embedder::rt::trap::Trap::trap(embedder::rt::trap::UnreachableError, Some({ const F: embedder::rt::trace::WasmFrame = Module::_frame_fn_3(1); &F })));
}

pub fn unreachable_instruction(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Self::_f3()
}

fn _f4(mut _l0: i32) -> i32 {
    let _t0 = '_b0: { if _l0 == 0x2Ai32 {
        0x42424242i32
    } else {
        0xDEADi32
    } }; // '_b0
    _t0
}

pub fn life(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f4(_l0))
}

fn _f5() {
}

pub fn do_nothing(&self) -> ::core::result::Result<(), embedder::Trap> {
    Ok(Self::_f5())
}

fn _f6(mut _l0: i32) -> i64 {
    let mut _l1 = 0i64;
    '_b0: { if _l0 == 0 {
        return 1i64;
    } } // '_b0
    _l1 = 1i64;
    let _t0 = '_b0: loop {
        _l1 = i64::wrapping_mul(_l0 as u32 as i64, _l1);
        let _t0 = '_b1: { if 1i64 == _l0 as u32 as i64 {
            _l1
        } else {
            _l0 = i32::wrapping_sub(_l0, 1i32);
            continue '_b0;
        } }; // '_b1
        break '_b0 _t0;
    }; // '_b0
    _t0
}

pub fn loop_factorial_unsigned(&self, mut _l0: i32) -> ::core::result::Result<i64, embedder::Trap> {
    Ok(Self::_f6(_l0))
}

fn _f7(mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    let _t0 = 0x000000000031A08Di64;
    let _t1 = 0x26CCi32;
    let _t2 = 0xCDFi64;
    '_b0: {
        let mut _b1_0 = _l0;
        '_b1: loop {
            '_b2: { if embedder::rt::math::i32_rem_u(_b1_0, 2i32).trap_with(Some({ const F: embedder::rt::trace::WasmFrame = Module::_frame_fn_7(21); &F }))? == 0 {
                return Ok(());
            } } // '_b2
            _b1_0 = 1i32;
            continue '_b1;
        } // '_b1
    } // '_b0
    return ::core::result::Result::Err(embedder::rt::trap::Trap::trap(embedder::rt::trap::UnreachableError, Some({ const F: embedder::rt::trace::WasmFrame = Module::_frame_fn_7(33); &F })));
}

pub fn halt_on_even(&self, mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    Self::_f7(_l0)
}

fn _f8(&self) -> i32 {
    Self::_G0
}

pub fn size_of_kibibyte(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(self._f8())
}

fn _f9(&self) {
    embedder::rt::global::Global::set(&self._g1, i32::wrapping_add(self._g1.get(), 1i32));
}

pub fn increment_counter(&self) -> ::core::result::Result<(), embedder::Trap> {
    Ok(self._f9())
}

fn _f10() -> (i32, i64, f32) {
    (0i32, 0i64, f32::from_bits(0x00000000))
}

fn _f11(&self) -> ::core::result::Result<(), embedder::Trap> {
    let mut _l0 = 0i32;
    let mut _l1 = 0i64;
    let mut _l2 = 0f32;
    let (_t0, _t1, _t2) = Self::_f10();
    _l2 = _t2;
    _l1 = _t1;
    _l0 = _t0;
    Ok(())
}

fn _f12(mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    '_b0: {
        if _l0 == 3i32 { break '_b0;}
        return Ok(());
    } // '_b0
    return ::core::result::Result::Err(embedder::rt::trap::Trap::trap(embedder::rt::trap::UnreachableError, Some({ const F: embedder::rt::trace::WasmFrame = Module::_frame_fn_12(12); &F })));
}

pub fn trap_on_three(&self, mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    Self::_f12(_l0)
}

fn _f13(mut _l0: i32) -> i64 {
    _l0 as i64
}

pub fn export_once_shame_on_you(&self, mut _l0: i32) -> ::core::result::Result<i64, embedder::Trap> {
    Ok(Self::_f13(_l0))
}

pub fn export_twice_shame_on_me(&self, mut _l0: i32) -> ::core::result::Result<i64, embedder::Trap> {
    Ok(Self::_f13(_l0))
}

pub fn export_three_times_shame_on_us(&self, mut _l0: i32) -> ::core::result::Result<i64, embedder::Trap> {
    Ok(Self::_f13(_l0))
}
    const _SYM_FN_0: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(0, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 361 }); sym.export_names = &["add_five"]; sym };
    const fn _frame_fn_0(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_0, o) }
    const _SYM_FN_1: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(1, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 370 }); sym.export_names = &["add_fifteen"]; sym };
    const fn _frame_fn_1(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_1, o) }
    const _SYM_FN_2: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(2, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 381 }); sym.export_names = &["block_me_up"]; sym };
    const fn _frame_fn_2(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_2, o) }
    const _SYM_FN_3: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(3, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 392 }); sym.export_names = &["unreachable_instruction"]; sym };
    const fn _frame_fn_3(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_3, o) }
    const _SYM_FN_4: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(4, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 396 }); sym.export_names = &["life"]; sym };
    const fn _frame_fn_4(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_4, o) }
    const _SYM_FN_5: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(5, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 418 }); sym.export_names = &["do_nothing"]; sym };
    const fn _frame_fn_5(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_5, o) }
    const _SYM_FN_6: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(6, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[embedder::rt::symbol::WasmValType::I64] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 421 }); sym.export_names = &["loop_factorial_unsigned"]; sym };
    const fn _frame_fn_6(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_6, o) }
    const _SYM_FN_7: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(7, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 471 }); sym.export_names = &["halt_on_even"]; sym };
    const fn _frame_fn_7(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_7, o) }
    const _SYM_FN_8: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(8, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[embedder::rt::symbol::WasmValType::I32] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 507 }); sym.export_names = &["size_of_kibibyte"]; sym };
    const fn _frame_fn_8(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_8, o) }
    const _SYM_FN_9: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(9, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 512 }); sym.export_names = &["increment_counter"]; sym };
    const fn _frame_fn_9(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_9, o) }
    const _SYM_FN_11: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(11, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 534 }); sym };
    const fn _frame_fn_11(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_11, o) }
    const _SYM_FN_12: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(12, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 551 }); sym.export_names = &["trap_on_three"]; sym };
    const fn _frame_fn_12(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_12, o) }
    const _SYM_FN_13: embedder::rt::symbol::WasmSymbol = { let mut sym = embedder::rt::symbol::WasmSymbol::new(13, &embedder::rt::symbol::WasmSymbolSignature { parameters: &[embedder::rt::symbol::WasmValType::I32], results: &[embedder::rt::symbol::WasmValType::I64] }, embedder::rt::symbol::WasmSymbolKind::Defined { offset: 566 }); sym.export_names = &["export_once_shame_on_you", "export_twice_shame_on_me", "export_three_times_shame_on_us"]; sym };
    const fn _frame_fn_13(o: u32) -> embedder::rt::trace::WasmFrame { embedder::rt::trace::WasmFrame::new(&Self::_SYM_FN_13, o) }

} // impl Module

impl Instance {
    pub fn instantiate(store: embedder::Store) -> ::core::result::Result<Self, embedder::Trap> {
        let allocated = Module {
            imports: store.imports,
            _g1: embedder::rt::global::Global::<_>::ZERO,
        };
        let mut module = embedder::rt::store::AllocateModule::allocate(store.instance, allocated);
        let mut inst: &mut Module = embedder::rt::store::ModuleAllocation::get_mut(&mut module);
        *inst._g1.get_mut() = 0i32;
        Ok(Self(Some(module)))
    }

    pub fn leak(module: Self) -> embedder::Module<Module> {
        let mut module = ::core::mem::ManuallyDrop::new(module);
        ::core::mem::take(&mut module.0).unwrap()
    }
} // impl Instance

impl ::core::ops::Deref for Instance {
    type Target = embedder::Module<Module>;

    fn deref(&self) -> &Self::Target {
        self.0.as_ref().unwrap()
    }
} // impl Deref

impl ::core::ops::Drop for Instance {

    fn drop(&mut self) {
        if embedder::rt::thread::panicking() {
            return;
        }

        let _module = embedder::rt::store::ModuleAllocation::get_mut(self.0.as_mut().unwrap());
    }
} // impl Drop

} // mod $module

    }
}
