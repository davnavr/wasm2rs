---
source: crates/convert/tests/main.rs
expression: "String::from_utf8_lossy(&rust)"
---
// Generated by wasm2rs 0.1.0
macro_rules! wasm {
    ($vis:vis mod $module:ident use $(:: $embedder_start:ident ::)? $($embedder_more:ident)::+) => {

#[allow(non_snake_case)]
#[allow(dead_code)]
#[allow(unreachable_code)]
#[allow(unreachable_pub)]
$vis mod $module {

use $(::$embedder_start::)? $($embedder_more)::+ as embedder;
use embedder::rt::trap::TrapWith as _;

pub struct Instance {
    imports: embedder::Imports,
    _g1: embedder::rt::global::Global<i32>,
}

impl Instance {
    const _G0: i32 = 0x400i32;

    pub fn r#counter(&self) -> &embedder::rt::global::Global<i32> {
        &self._g1
    }

    pub fn instantiate(store: embedder::Store) -> ::core::result::Result<embedder::Module<Self>, embedder::Trap> {
        let allocated = Self {
            imports: store.imports,
            _g1: embedder::rt::global::Global::<_>::ZERO,
        };
        let mut module = embedder::rt::store::AllocateModule::allocate(store.instance, allocated);
        let mut inst: &mut Self = embedder::rt::store::ModuleAllocation::get_mut(&mut module);
        *inst._g1.get_mut() = 0i32;
        Ok(module)
    }

fn _f0(mut _l0: i32) -> i32 {
    i32::wrapping_add(_l0, 5i32)
}

pub fn r#add_five(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f0(_l0))
}

pub fn r#add_fifteen(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f0(Self::_f0(Self::_f0(_l0))))
}

fn _f2(mut _l0: i32) -> i32 {
    let (_t0, _t1) = '_b0: {
        (_l0, _l0)
    }; // '_b0
    i32::wrapping_add(_t0, _t1)
}

pub fn r#block_me_up(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f2(_l0))
}

fn _f3() -> ::core::result::Result<i32 /* ! */, embedder::Trap> {
    return ::core::result::Result::Err(embedder::rt::trap::Trap::trap(embedder::rt::trap::UnreachableError, None));
}

pub fn r#unreachable_instruction(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Self::_f3()
}

fn _f4(mut _l0: i32) -> i32 {
    let _t0 = '_b0: { if _l0 == 0x2Ai32 {
        0x42424242i32
    } else {
        0xDEADi32
    } }; // '_b0
    _t0
}

pub fn r#life(&self, mut _l0: i32) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f4(_l0))
}

fn _f5() {
}

pub fn r#do_nothing(&self) -> ::core::result::Result<(), embedder::Trap> {
    Ok(Self::_f5())
}

fn _f6(mut _l0: i32) -> i64 {
    let mut _l1 = 0i64;
    '_b0: { if _l0 == 0 {
        return 1i64;
    } } // '_b0
    _l1 = 1i64;
    let _t0 = '_b0: loop {
        _l1 = i64::wrapping_mul(_l0 as u32 as i64, _l1);
        let _t0 = '_b1: { if 1i64 == _l0 as u32 as i64 {
            _l1
        } else {
            _l0 = i32::wrapping_sub(_l0, 1i32);
            continue '_b0;
        } }; // '_b1
        break '_b0 _t0;
    }; // '_b0
    _t0
}

pub fn r#loop_factorial_unsigned(&self, mut _l0: i32) -> ::core::result::Result<i64, embedder::Trap> {
    Ok(Self::_f6(_l0))
}

fn _f7(mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    let _t0 = 0x000000000031A08Di64;
    let _t1 = 0x26CCi32;
    let _t2 = 0xCDFi64;
    '_b0: {
        let mut _b1_0 = _l0;
        '_b1: loop {
            '_b2: { if embedder::rt::math::i32_rem_u(_b1_0, 2i32).trap_with(None)? == 0 {
                return Ok(());
            } } // '_b2
            _b1_0 = 1i32;
            continue '_b1;
        } // '_b1
    } // '_b0
    return ::core::result::Result::Err(embedder::rt::trap::Trap::trap(embedder::rt::trap::UnreachableError, None));
}

pub fn r#halt_on_even(&self, mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    Self::_f7(_l0)
}

fn _f8() -> i32 {
    Self::_G0
}

pub fn r#size_of_kibibyte(&self) -> ::core::result::Result<i32, embedder::Trap> {
    Ok(Self::_f8())
}

fn _f9(&self) {
    embedder::rt::global::Global::set(&self._g1, i32::wrapping_add(self._g1.get(), 1i32));
}

pub fn r#increment_counter(&self) -> ::core::result::Result<(), embedder::Trap> {
    Ok(self._f9())
}

fn _f10() -> (i32, i64, f32) {
    (0i32, 0i64, f32::from_bits(0x00000000))
}

fn _f11(&self) -> ::core::result::Result<(), embedder::Trap> {
    let mut _l0 = 0i32;
    let mut _l1 = 0i64;
    let mut _l2 = 0f32;
    let (_t0, _t1, _t2) = Self::_f10();
    _l2 = _t2;
    _l1 = _t1;
    _l0 = _t0;
    Ok(())
}

fn _f12(mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    '_b0: {
        if _l0 == 3i32 { break '_b0;}
        return Ok(());
    } // '_b0
    return ::core::result::Result::Err(embedder::rt::trap::Trap::trap(embedder::rt::trap::UnreachableError, None));
}

pub fn r#trap_on_three(&self, mut _l0: i32) -> ::core::result::Result<(), embedder::Trap> {
    Self::_f12(_l0)
}

} // impl Instance

} // mod $module

    }
}
