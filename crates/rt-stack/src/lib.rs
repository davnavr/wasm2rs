//! Implements call stack overflow checks for `wasm2rs`.

#![no_std]
#![cfg_attr(docsrs, feature(doc_auto_cfg))]
#![forbid(unsafe_code)]
#![deny(missing_debug_implementations)]
#![deny(missing_docs)]
#![deny(unreachable_pub)]
#![deny(clippy::cast_possible_truncation)]
#![deny(clippy::alloc_instead_of_core)]
#![deny(clippy::std_instead_of_core)]

#[cfg(feature = "std")]
extern crate std;

use wasm2rs_rt_core::trap::Trap;

/// Error type used if a stack overflow was detected.
///
/// See the documentation for the [`check_for_overflow()`] function for more information.
#[derive(Clone, Copy, Debug, Eq, Hash, PartialEq)]
#[non_exhaustive]
pub struct StackOverflowError;

impl core::fmt::Display for StackOverflowError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.write_str("call stack exhausted")
    }
}

#[cfg(feature = "std")]
impl std::error::Error for StackOverflowError {}

/// Checks if there is enough space on the stack for approximately `amount` bytes worth of
/// variables.
///
/// # Reliability
///
/// This function will not exactly detect all stack overflows. It may indicate that a stack
/// overflow would occur even if there was stack space remaining. It may also fail to detect a
/// stack overflow. Code generated by `wasm2rs` will attempt to overestimate the amount of stack
/// space used for functions.
///
/// # Availability
///
/// If the `enabled` feature is enabled, it uses the [`stacker::remaining_stack()`]
/// function to estimate the remaining stack space. In situations where the remaining stack space
/// cannot be queried, or if the feature is not enabled, this function does nothing.
///
/// # Handling a [`StackOverflowError`]
///
/// To ensure that program execution is not aborted when [`Trap::trap()`] is called, implementors
/// of the [`Trap`] trait must avoid allocating too much space on the stack when implementing
/// `Trap<StackOverflowError>`.
///
/// # Errors
///
/// If stack overflow detection is enabled and a stack overflow could occur, a [`Trap`] is produced.
#[inline]
pub fn check_for_overflow<E>(
    amount: usize,
    frame: Option<&'static wasm2rs_rt_core::trace::WasmFrame>,
) -> Result<(), E>
where
    E: Trap<StackOverflowError>,
{
    #[cfg(not(feature = "enabled"))]
    return {
        let _ = amount;
        let _ = frame;
        Ok(())
    };

    #[cfg(feature = "enabled")]
    return {
        /// Constant amount to add to the `amount` to check for.
        ///
        /// In most ABIs, a function call pushes a return address and does other alignment stuff.
        /// This arbitrary value mostly accounts for extra stuff that may be pushed onto the stack.
        ///
        /// This also ensures extra space is reserved for calling [`Trap::trap()`].
        const CALL_OVERHEAD: usize = 4096;

        match stacker::remaining_stack() {
            None => Ok(()),
            Some(remaining) if remaining >= amount.saturating_add(CALL_OVERHEAD) => Ok(()),
            Some(_) => Err(E::trap(StackOverflowError, frame)),
        }
    };
}
